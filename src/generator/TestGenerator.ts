import * as fs from 'fs';
import * as path from 'path';
import { StateGraphData, StateTransition, AppState, Action } from '../types';

export interface TestGeneratorConfig {
  outputDir: string;
  baseUrl: string;
  testPrefix: string;
  generateStateTests: boolean;
  generateTransitionTests: boolean;
  generatePathTests: boolean;
}

const DEFAULT_CONFIG: TestGeneratorConfig = {
  outputDir: './generated-tests',
  baseUrl: 'http://localhost:3000',
  testPrefix: 'waggen',
  generateStateTests: true,
  generateTransitionTests: true,
  generatePathTests: true,
};

export class TestGenerator {
  private config: TestGeneratorConfig;
  private graph: StateGraphData;

  constructor(graph: StateGraphData, config: Partial<TestGeneratorConfig> = {}) {
    this.graph = graph;
    this.config = { ...DEFAULT_CONFIG, ...config };
  }

  generate(): string[] {
    const generatedFiles: string[] = [];

    // Ensure output directory exists
    if (!fs.existsSync(this.config.outputDir)) {
      fs.mkdirSync(this.config.outputDir, { recursive: true });
    }

    // Generate state verification tests
    if (this.config.generateStateTests) {
      const stateTestFile = this.generateStateTests();
      generatedFiles.push(stateTestFile);
    }

    // Generate transition tests
    if (this.config.generateTransitionTests) {
      const transitionTestFile = this.generateTransitionTests();
      generatedFiles.push(transitionTestFile);
    }

    // Generate path/journey tests
    if (this.config.generatePathTests) {
      const pathTestFile = this.generatePathTests();
      generatedFiles.push(pathTestFile);
    }

    // Generate test utilities
    const utilsFile = this.generateTestUtils();
    generatedFiles.push(utilsFile);

    // Generate Playwright config
    const configFile = this.generatePlaywrightConfig();
    generatedFiles.push(configFile);

    return generatedFiles;
  }

  private generateStateTests(): string {
    const lines: string[] = [
      `import { test, expect } from '@playwright/test';`,
      `import { navigateToState, verifyState } from './test-utils';`,
      ``,
      `/**`,
      ` * State Verification Tests`,
      ` * Generated by Waggen from state graph`,
      ` * Generated: ${new Date().toISOString()}`,
      ` */`,
      ``,
      `test.describe('State Verification', () => {`,
      `  test.beforeEach(async ({ page }) => {`,
      `    await page.goto('${this.config.baseUrl}');`,
      `  });`,
      ``,
    ];

    for (const [stateId, state] of Object.entries(this.graph.states)) {
      const testName = this.sanitizeTestName(state.description);
      lines.push(`  test('${stateId}: ${testName}', async ({ page }) => {`);

      // Navigate to state if not entry state
      if (stateId !== this.graph.entryStateId) {
        const path = this.graph.paths[stateId]?.[0];
        if (path && path.length > 1) {
          lines.push(`    // Navigate to state`);
          lines.push(`    await navigateToState(page, '${stateId}');`);
          lines.push(``);
        }
      }

      // Verify elements exist
      lines.push(`    // Verify state elements`);
      for (const element of state.elements) {
        const selector = this.escapeSelector(element.selector);
        lines.push(`    await expect(page.locator('${selector}')).toBeVisible();`);
      }

      lines.push(`  });`);
      lines.push(``);
    }

    lines.push(`});`);

    const filePath = path.join(this.config.outputDir, `${this.config.testPrefix}-states.spec.ts`);
    fs.writeFileSync(filePath, lines.join('\n'));
    return filePath;
  }

  private generateTransitionTests(): string {
    const lines: string[] = [
      `import { test, expect } from '@playwright/test';`,
      `import { navigateToState, performAction } from './test-utils';`,
      ``,
      `/**`,
      ` * Transition Tests`,
      ` * Generated by Waggen from state graph`,
      ` * Generated: ${new Date().toISOString()}`,
      ` */`,
      ``,
      `test.describe('State Transitions', () => {`,
      `  test.beforeEach(async ({ page }) => {`,
      `    await page.goto('${this.config.baseUrl}');`,
      `  });`,
      ``,
    ];

    // Group transitions by source state
    const transitionsBySource = new Map<string, StateTransition[]>();
    for (const transition of this.graph.transitions) {
      const existing = transitionsBySource.get(transition.fromStateId) || [];
      existing.push(transition);
      transitionsBySource.set(transition.fromStateId, existing);
    }

    // Only generate unique transition tests
    const seenTransitions = new Set<string>();

    for (const [sourceStateId, transitions] of transitionsBySource) {
      const sourceState = this.graph.states[sourceStateId];

      for (const transition of transitions) {
        const transitionKey = `${transition.fromStateId}->${transition.toStateId}:${transition.action.type}:${transition.action.elementSelector}`;
        if (seenTransitions.has(transitionKey)) continue;
        seenTransitions.add(transitionKey);

        const targetState = this.graph.states[transition.toStateId];
        const actionDesc = this.describeAction(transition.action);
        const testName = `${sourceStateId} -> ${transition.toStateId}: ${actionDesc}`;

        lines.push(`  test('${this.sanitizeTestName(testName)}', async ({ page }) => {`);

        // Navigate to source state if needed
        if (sourceStateId !== this.graph.entryStateId) {
          lines.push(`    // Navigate to source state: ${sourceState.description}`);
          lines.push(`    ${this.generateNavigationCode(sourceStateId)}`);
          lines.push(``);
        }

        // Perform action
        lines.push(`    // Perform action: ${actionDesc}`);
        lines.push(`    ${this.generateActionCode(transition.action)}`);
        lines.push(``);

        // Verify result state
        lines.push(`    // Verify transition to: ${targetState.description}`);
        if (transition.toStateId === transition.fromStateId) {
          lines.push(`    // State should remain unchanged`);
        }

        // Add a visible element assertion from target state
        const targetElement = targetState.elements[0];
        if (targetElement) {
          const selector = this.escapeSelector(targetElement.selector);
          lines.push(`    await expect(page.locator('${selector}')).toBeVisible();`);
        }

        lines.push(`  });`);
        lines.push(``);
      }
    }

    lines.push(`});`);

    const filePath = path.join(this.config.outputDir, `${this.config.testPrefix}-transitions.spec.ts`);
    fs.writeFileSync(filePath, lines.join('\n'));
    return filePath;
  }

  private generatePathTests(): string {
    const lines: string[] = [
      `import { test, expect } from '@playwright/test';`,
      `import { performAction } from './test-utils';`,
      ``,
      `/**`,
      ` * User Journey Tests`,
      ` * Generated by Waggen from state graph`,
      ` * Generated: ${new Date().toISOString()}`,
      ` */`,
      ``,
      `test.describe('User Journeys', () => {`,
      `  test.beforeEach(async ({ page }) => {`,
      `    await page.goto('${this.config.baseUrl}');`,
      `  });`,
      ``,
    ];

    // Generate a test for each unique path to non-entry states
    for (const [targetStateId, paths] of Object.entries(this.graph.paths)) {
      if (targetStateId === this.graph.entryStateId) continue;
      if (!paths || paths.length === 0) continue;

      const targetState = this.graph.states[targetStateId];
      const shortestPath = paths[0];

      if (shortestPath.length < 2) continue;

      const pathDesc = shortestPath.join(' -> ');
      const testName = `Journey to: ${targetState.description}`;

      lines.push(`  test('${this.sanitizeTestName(testName)}', async ({ page }) => {`);
      lines.push(`    // Path: ${pathDesc}`);
      lines.push(``);

      // Generate steps for each transition in the path
      for (let i = 0; i < shortestPath.length - 1; i++) {
        const fromStateId = shortestPath[i];
        const toStateId = shortestPath[i + 1];

        // Find the transition
        const transition = this.graph.transitions.find(
          t => t.fromStateId === fromStateId && t.toStateId === toStateId
        );

        if (transition) {
          const fromState = this.graph.states[fromStateId];
          const toState = this.graph.states[toStateId];

          lines.push(`    // Step ${i + 1}: ${fromState.description} -> ${toState.description}`);
          lines.push(`    ${this.generateActionCode(transition.action)}`);
          lines.push(`    await page.waitForTimeout(300);`);
          lines.push(``);
        }
      }

      // Verify final state
      lines.push(`    // Verify final state: ${targetState.description}`);
      for (const element of targetState.elements.slice(0, 3)) {
        const selector = this.escapeSelector(element.selector);
        lines.push(`    await expect(page.locator('${selector}')).toBeVisible();`);
      }

      lines.push(`  });`);
      lines.push(``);
    }

    lines.push(`});`);

    const filePath = path.join(this.config.outputDir, `${this.config.testPrefix}-journeys.spec.ts`);
    fs.writeFileSync(filePath, lines.join('\n'));
    return filePath;
  }

  private generateTestUtils(): string {
    const lines: string[] = [
      `import { Page, expect } from '@playwright/test';`,
      ``,
      `/**`,
      ` * Test Utilities`,
      ` * Generated by Waggen`,
      ` */`,
      ``,
      `// State navigation map - shortest paths from entry state`,
      `export const STATE_PATHS: Record<string, Array<{ action: string; selector: string; value?: string }>> = {`,
    ];

    // Generate navigation paths for each state
    for (const [stateId, paths] of Object.entries(this.graph.paths)) {
      if (stateId === this.graph.entryStateId || !paths || paths.length === 0) {
        lines.push(`  '${stateId}': [],`);
        continue;
      }

      const shortestPath = paths[0];
      const steps: string[] = [];

      for (let i = 0; i < shortestPath.length - 1; i++) {
        const fromStateId = shortestPath[i];
        const toStateId = shortestPath[i + 1];

        const transition = this.graph.transitions.find(
          t => t.fromStateId === fromStateId && t.toStateId === toStateId
        );

        if (transition) {
          const step = {
            action: transition.action.type,
            selector: transition.action.elementSelector,
            value: transition.action.value,
          };
          steps.push(JSON.stringify(step));
        }
      }

      lines.push(`  '${stateId}': [${steps.join(', ')}],`);
    }

    lines.push(`};`);
    lines.push(``);
    lines.push(`// Navigate to a specific state from entry`);
    lines.push(`export async function navigateToState(page: Page, stateId: string): Promise<void> {`);
    lines.push(`  const steps = STATE_PATHS[stateId];`);
    lines.push(`  if (!steps) {`);
    lines.push(`    throw new Error(\`Unknown state: \${stateId}\`);`);
    lines.push(`  }`);
    lines.push(``);
    lines.push(`  for (const step of steps) {`);
    lines.push(`    await performAction(page, step.action, step.selector, step.value);`);
    lines.push(`    await page.waitForTimeout(300);`);
    lines.push(`  }`);
    lines.push(`}`);
    lines.push(``);
    lines.push(`// Perform an action on the page`);
    lines.push(`export async function performAction(`);
    lines.push(`  page: Page,`);
    lines.push(`  action: string,`);
    lines.push(`  selector: string,`);
    lines.push(`  value?: string`);
    lines.push(`): Promise<void> {`);
    lines.push(`  const element = page.locator(selector).first();`);
    lines.push(``);
    lines.push(`  switch (action) {`);
    lines.push(`    case 'click':`);
    lines.push(`      await element.click();`);
    lines.push(`      break;`);
    lines.push(`    case 'input':`);
    lines.push(`      await element.fill(value || '');`);
    lines.push(`      await page.keyboard.press('Enter');`);
    lines.push(`      break;`);
    lines.push(`    case 'check':`);
    lines.push(`      await element.click();`);
    lines.push(`      break;`);
    lines.push(`    case 'select':`);
    lines.push(`      await element.selectOption(value || '');`);
    lines.push(`      break;`);
    lines.push(`    default:`);
    lines.push(`      throw new Error(\`Unknown action: \${action}\`);`);
    lines.push(`  }`);
    lines.push(`}`);
    lines.push(``);
    lines.push(`// Verify a state by checking its elements`);
    lines.push(`export async function verifyState(page: Page, stateId: string): Promise<void> {`);
    lines.push(`  // State verification is done inline in tests`);
    lines.push(`  // This function can be extended for more complex verification`);
    lines.push(`}`);

    const filePath = path.join(this.config.outputDir, 'test-utils.ts');
    fs.writeFileSync(filePath, lines.join('\n'));
    return filePath;
  }

  private generatePlaywrightConfig(): string {
    const config = `import { defineConfig, devices } from '@playwright/test';

/**
 * Playwright Configuration
 * Generated by Waggen
 */
export default defineConfig({
  testDir: '.',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',

  use: {
    baseURL: '${this.config.baseUrl}',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
  },

  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
  ],

  webServer: {
    command: 'npx serve ../sample-app -p 3000',
    url: '${this.config.baseUrl}',
    reuseExistingServer: !process.env.CI,
  },
});
`;

    const filePath = path.join(this.config.outputDir, 'playwright.config.ts');
    fs.writeFileSync(filePath, config);
    return filePath;
  }

  private generateActionCode(action: Action): string {
    const selector = this.escapeSelector(action.elementSelector);

    switch (action.type) {
      case 'click':
        return `await page.locator('${selector}').click();`;
      case 'input':
        return `await page.locator('${selector}').fill('${action.value || 'Test input'}');\n    await page.keyboard.press('Enter');`;
      case 'check':
        return `await page.locator('${selector}').click();`;
      case 'select':
        return `await page.locator('${selector}').selectOption('${action.value || ''}');`;
      default:
        return `// Unknown action: ${action.type}`;
    }
  }

  private generateNavigationCode(stateId: string): string {
    return `await navigateToState(page, '${stateId}');`;
  }

  private describeAction(action: Action): string {
    switch (action.type) {
      case 'click':
        return `click "${action.elementLabel}"`;
      case 'input':
        return `input "${action.value}" into "${action.elementLabel}"`;
      case 'check':
        return `toggle "${action.elementLabel}"`;
      case 'select':
        return `select "${action.value}" from "${action.elementLabel}"`;
      default:
        return `${action.type} on "${action.elementLabel}"`;
    }
  }

  private sanitizeTestName(name: string): string {
    return name
      .replace(/['"]/g, '')
      .replace(/\n/g, ' ')
      .replace(/\s+/g, ' ')
      .trim()
      .slice(0, 80);
  }

  private escapeSelector(selector: string): string {
    return selector.replace(/'/g, "\\'");
  }
}
